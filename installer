<?php
/**
 * @file
 * Backup CLI installer.
 * Based on platform.sh CLI installer.
 */

define('MANIFEST_URL', 'https://fabioneves.github.io/backup-cli/manifest.json');
$pharFilename = 'backup-cli.phar';

set_error_handler(
    function ($code, $message) {
        if ($code & error_reporting()) {
            echo PHP_EOL . "Error ($code): $message" . PHP_EOL;
            exit(1);
        }
    }
);

output("Backup CLI installer", 'heading');

// Run environment checks.
output(PHP_EOL . "Environment check", 'heading');

// Check the PHP version.
$min_php = '5.5.9';
check(
    sprintf('The PHP version is supported: %s.', PHP_VERSION),
    sprintf('The PHP version is %s, but %s or greater is required.', PHP_VERSION, $min_php),
    function () use ($min_php) {
        return version_compare(PHP_VERSION, $min_php, '>=');
    }
);

// Check that the openssl extension exists.
check(
    'The "openssl" PHP extension is installed.',
    'Warning: the "openssl" PHP extension will be needed.',
    function () {
        return extension_loaded('openssl');
    },
    false
);

// Check that the curl extension exists.
check(
    'The "curl" PHP extension is installed.',
    'Warning: the "curl" PHP extension will be needed.',
    function () {
        return extension_loaded('curl');
    },
    false
);

// Check Suhosin restrictions.
if (extension_loaded('suhosin')) {
    check(
        'The "phar" stream wrapper is allowed by Suhosin.',
        'The "phar" stream wrapper is blocked by Suhosin.',
        function () {
            $white = ini_get('suhosin.executor.include.whitelist');
            $black = ini_get('suhosin.executor.include.blacklist');

            if ((false === stripos($white, 'phar'))
                || (false !== stripos($black, 'phar'))
            ) {
                return false;
            }

            return true;
        }
    );
}

// Check whether PHP can open files via URLs.
check(
    'The "allow_url_fopen" setting is on.',
    'The "allow_url_fopen" setting is off; it must be on.',
    function () {
        return (true == ini_get('allow_url_fopen'));
    }
);

// Check a troublesome APC setting.
check(
    'The "apc.enable_cli" setting is off.',
    'Warning: the "apc.enable_cli" is on; this may cause problems with Phar files.',
    function () {
        return (false == ini_get('apc.enable_cli'));
    },
    false
);

// The necessary checks have passed. Start downloading the right version.
output(PHP_EOL . "Download", 'heading');

output("  Finding the latest version...");
$manifest = file_get_contents(MANIFEST_URL);
if ($manifest === false) {
    output("  Failed to download manifest file: " . MANIFEST_URL, 'error');
    exit(1);
}

$manifest = json_decode($manifest);
if ($manifest === null) {
    output("  Failed to decode manifest file: " . MANIFEST_URL, 'error');
    exit(1);
}

// Find the item with the greatest version number in the manifest.
/** @var stdClass|null $latest */
$latest = null;
foreach ($manifest as $item) {
    if (empty($latest) || version_compare($item->version, $latest->version, '>')) {
        $latest = $item;
    }
}
if (empty($latest)) {
    output("  No download was found.", 'error');
    exit(1);
}

output("  Downloading version {$latest->version}...");
if (!file_put_contents($pharFilename, file_get_contents($latest->url))) {
    output("  The download failed.", 'error');
}

output("  Checking file integrity...");
if ($latest->sha1 !== sha1_file($pharFilename)) {
    unlink($pharFilename);
    output("  The download was corrupted.", 'error');
    exit(1);
}

output("  Checking that the file is a valid Phar (PHP Archive)...");

try {
    new Phar($pharFilename);
} catch (Exception $e) {
    output("  The file is not a valid Phar archive.", 'error');

    throw $e;
}

output("  Making the Phar executable...");
chmod($pharFilename, 0755);
$executable = $pharFilename;

output(
    PHP_EOL . "The Backup CLI v{$latest->version} was installed successfully!",
    'success'
);

/**
 * Checks a condition, outputs a message, and exits if failed.
 *
 * @param string   $success   The success message.
 * @param string   $failure   The failure message.
 * @param callable $condition The condition to check.
 * @param bool     $exit      Whether to exit on failure.
 */
function check($success, $failure, $condition, $exit = true)
{
    if ($condition()) {
        output('  [*] ' . $success, 'success');
    } else {
        output('  [ ] ' . $failure, $exit ? 'error' : 'warning');

        if ($exit) {
            exit(1);
        }
    }
}

/**
 * Outputs formatted text.
 *
 * @param string $text
 * @param string $color
 * @param bool   $newLine
 */
function output($text, $color = null, $newLine = true)
{
    static $ansi;
    if (!isset($ansi)) {
        global $argv;
        if (in_array('--no-ansi', $argv)) {
            $ansi = false;
        } elseif (in_array('--ansi', $argv)) {
            $ansi = true;
        } else {
            // On Windows, default to no ANSI, except in ANSICON and ConEmu.
            // Everywhere else, default to ANSI if stdout is a terminal.
            $ansi = (DIRECTORY_SEPARATOR == '\\')
                ? (false !== getenv('ANSICON') || 'ON' === getenv('ConEmuANSI'))
                : (function_exists('posix_isatty') && posix_isatty(1));
        }
    }

    static $styles = array(
        'success' => "\033[0;32m%s\033[0m",
        'error' => "\033[31;31m%s\033[0m",
        'info' => "\033[33m%s\033[39m",
        'warning' => "\033[33m%s\033[39m",
        'heading' => "\033[1;33m%s\033[22;39m",
    );

    $format = '%s';

    if (isset($styles[$color]) && $ansi) {
        $format = $styles[$color];
    }

    if ($newLine) {
        $format .= PHP_EOL;
    }

    printf($format, $text);
}

